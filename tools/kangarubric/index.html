<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kangarubric - Canvas Rubric Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="roo.png">
    
    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" href="roo.png">
    <link rel="apple-touch-icon" sizes="152x152" href="roo.png">
    <link rel="apple-touch-icon" sizes="180x180" href="roo.png">
    <link rel="apple-touch-icon" sizes="167x167" href="roo.png">
    <script src="https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js"></script>
    <style>
        :root {
            --primary-color: #2c5530;     /* Dark forest green */
            --secondary-color: #4a7350;  /* Medium forest green */
            --tertiary-color: #e1eae1; /* Sage */
            --background-color: #f4f7f4; /* Light sage */
            --text-color: #1a1f1a;      /* Dark green-gray */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 30px;
        }

        .drop-zone {
            border: 2px dashed var(--primary-color);
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            background-color: white;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .drop-zone.dragover {
            background-color: rgba(0, 122, 255, 0.1);
            border-color: var(--secondary-color);
        }

        .drop-zone p {
            margin: 0;
            font-size: 1.2em;
            color: #666;
        }

        #fileInput {
            display: none;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: var(--secondary-color);
        }

        #output {
            margin-top: 30px;
            margin-bottom: 60px; /* Make room for footer */
        }

        footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--background-color);
            padding: 2px 20px;
            border-top: 1px solid var(--tertiary-color);
            font-size: 0.8em;
            color: var(--text-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
        }

        footer label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            user-select: none;
        }

        .rubric-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border-radius: 6px;
            overflow: hidden;
        }

        .rubric-table th, .rubric-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        .rubric-table th {
            background-color: var(--primary-color);
            color: white;
            padding: 12px;
            text-align: center;
            font-weight: 600;
        }
        
        .rubric-table th:first-child {
            text-align: left;
            width: 25%;
        }
        
        .rubric-table td:first-child {
            width: 25%;
        }
        
        .rubric-table td {
            width: 15%;
            vertical-align: top;
        }

        .rubric-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }



        .debug-entry {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #333;
        }

        .error-text {
            color: #FF3B30;
            font-weight: bold;
            display: block;
            margin-top: 4px;
        }

        .criterion-cell {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .criterion-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .criterion-name {
            font-weight: bold;
            color: var(--primary-color);
        }

        .criterion-score {
            color: #444;
        }

        .criterion-description {
            margin: 8px 0;
        }

        .criterion-clos {
            color: #666;
            font-size: 0.9em;
        }

        .instructions {
            background-color: var(--tertiary-color);
            border-radius: 6px;
            padding: 20px 30px;
            margin: 20px 0;
            color: var(--text-color);
        }

        .instructions p {
            margin: 15px 0;
            line-height: 1.6;
        }

        .instructions p strong {
            color: var(--primary-color);
        }

        /* Preserve whitespace in cell content */
        td p {
            white-space: pre-wrap;
        }

        /* Accordion styles */
        .rubric-accordion {
            margin-bottom: 1em;
        }

        .rubric-header {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            margin: 0;
            padding: 0.5em;
            background-color: var(--tertiary-color);
            border-radius: 4px;
        }

        .rubric-header:hover {
            background-color: #d4e1d4;
        }

        .rubric-header h2 {
            margin: 0;
            font-size: 1.2em;
        }

        .expand-icon {
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 6px 0 6px 10px;
            border-color: transparent transparent transparent var(--primary-color);
            margin-right: 10px;
            transition: transform 0.2s ease;
        }

        .expanded .expand-icon {
            transform: rotate(90deg);
        }

        .rubric-content {
            display: none;
            padding: 1em 0;
        }

        .expanded .rubric-content {
            display: block;
        }

        /* FAQ styles */
        .faq-section {
            margin-top: 3em;
            margin-bottom:3em;
            border-top: 1px solid var(--primary-color);
        }

        .faq-section h2 {
            color: var(--primary-color);
            margin-bottom: 1.5em;
        }

        .faq-item {
            margin-bottom: 0.5em;
        }

        .faq-header {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            padding: 0.75em;
            background-color: var(--tertiary-color);
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        .faq-header:hover {
            background-color: #d4e1d4;
        }

        .faq-header h3 {
            margin: 0;
            font-size: 1.1em;
            color: var(--primary-color);
        }

        .faq-content {
            display: none;
            padding: 1em;
            background-color: var(--background-color);
            border-radius: 0 0 4px 4px;
            margin-top: 2px;
        }

        .faq-item.expanded .faq-content {
            display: block;
        }

        /* Style the note paragraph */
        .instructions .note {
            background-color: var(--background-color);
            padding: 15px;
            border-left: 4px solid var(--primary-color);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            border-radius: 0 6px 6px 0;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            border-bottom: 1px solid var(--primary-color);
            transition: color 0.2s ease;
        }

        a:hover {
            color: var(--secondary-color);
            text-decoration: none;
            border-bottom: 2px solid var(--primary-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="roo.svg" alt="Kangaroo Logo" style="display: block; margin: 0 auto; width: 400px; height: 400px;">
        <h1>Kangarubric</h1>
        <div class="instructions">
            <p>Upload a course details Word document to generate Canvas rubric CSV files for each assessment rubric.</p>
            <p>If you encounter any errors, check that your Word document includes max point percentages and CLOs for all criteria. Save, re-upload and re-run the tool.</p>
            <p>To upload your CSV file to Canvas, simply navigate to 'Rubrics' in the course navigation menu. <br>Click 'Import Rubric', then upload the file you created with Kangarubric.</p>
            <p class="note"><strong>Note: </strong>Unfortunately, Canvas <a href="https://community.canvaslms.com/t5/Known-Issues/OPEN-Rubric-imports-cannot-process-decimal-values-for-rating/ta-p/631147" target="_blank">doesn't know how to handle decimal points in rubric CSV files</a>. <br>You'll need to manually change them after your import your rubric.<br>A fix is coming in a future Canvas update.</p>
            <p>If you're still running into trouble, please contact <a href="mailto:tim.churchward@adelaide.edu.au">Tim Churchward</a>.</p>
        </div>
        
        <div class="drop-zone" id="dropZone">
            <p>Drop your .docx file here or click to upload</p>
            <input type="file" id="fileInput" accept=".docx">
        </div>
        
        <div style="text-align: center;">
            <button id="processButton" disabled>Hop to it!</button>
        </div>

        <div id="output"></div>

        <div class="faq-section">
            <h2>Frequently Asked Questions</h2>
            <div class="faq-item">
                <div class="faq-header">
                    <div class="expand-icon"></div>
                    <h3>How do I import my CSV file into Canvas?</h3>
                </div>
                <div class="faq-content">
                    <ol>
                        <li>In your course, navigate to 'Rubrics' in the course menu on the left side.</li>
                        <li>In the top right, click 'Import rubric'.</li>
                        <li>Upload your CSV file.</li>
                        <li>After a moment, it should successfully import. You will see it appear in your rubrics list as a draft.</li>
                        <li>Click the three dots '...' on the right of your imported rubric and click 'Edit'.</li>
                        <li>Click 'Save'. You can now add it to an assignment.</li>
                    </ol>
                    <p>To add your rubric to an assignment:</p>
                    <ol>
                        <li>Navigate to 'Assignments' in the course menu on the left side.</li>
                        <li>Open an assignment.</li>
                        <li>Click '+ Rubric'.</li>
                        <li>Click 'Find a rubric' in the top right of the rubric editor.</li>
                        <li>Find your rubric and click 'Use this rubric'. You may need to scroll down to see the button.</li>
                    </ol>
                    <p>If you cannot see your rubric in the 'Find a rubric' list, make sure that your rubric is not still a draft. Refresh the assignment page. If you still cannot see it, try duplicating the rubric and see if the copy appears.</p>

                </div>
            </div>
            <div class="faq-item">
                <div class="faq-header">
                    <div class="expand-icon"></div>
                    <h3>How are points calculated?</h3>
                </div>
                <div class="faq-content">
                    <p>Using the following rules:</p>
                    <ul>
                        <li>HD: 100% - 85% of the max points for the criterion.</li>
                        <li>D: 85% - 75% of the max points for the criterion.</li>
                        <li>C: 75% - 65% of the max points for the criterion.</li>
                        <li>P: 65% - 50% of the max points for the criterion.</li>
                        <li>F: &lt;50% of the max points for the criterion.</li>
                    </ul>
                    <p>There is a 0.01 points 'gap' between each level. For example, if a given criterion is worth 50% of the marks, then a top score is 50 points, the low end of HD is 42.5 points, and the high end of D is 42.49 points.</p>
                    <p>Please note: As of 14/2/25, Canvas has a bug where decimal points <strong>will not import</strong> and instead are truncated to their floor values (i.e. 10.9 or 10.1 both become 10). This bug has been fixed but not yet pushed out in an update. Until that happens, please manually adjust the points after importing your rubric.</p>
                </div>
            </div>
            <div class="faq-item">
                <div class="faq-header">
                    <div class="expand-icon"></div>
                    <h3>Why are there no decimal points in the rating points?</h3>
                </div>
                <div class="faq-content">
                    <p>This is due to a bug in Canvas where decimal points <strong>will not import</strong> and instead are truncated to their floor values (i.e. 10.9 or 10.1 both become 10). This bug has been fixed but not yet pushed out in an update. Until that happens, please manually adjust the points after importing your rubric.</p>
                    <p>Kangarubric is correctly including the decimal point values in your CSV, but Canvas is not correctly interpreting them. Once Instructure fix this bug, you will immediately be able to re-import any rubric created using Kangarubric and it will work as expected.</p>
                </div>
            </div>
            <div class="faq-item">
                <div class="faq-header">
                    <div class="expand-icon"></div>
                    <h3>Why weren't any rubrics found in my document?</h3>
                </div>
                <div class="faq-content">
                    <p>Kangarubric only detects rubrics that use the AU Course Details form. If any headings or the rubric table have been modified (cells added or deleted), it may not work.</p>
                    <p>Specifically, it retrieves all tables between the "* Assessment Rubric" and "* Course Content Breakdown" headings, then processes them assuming that they follow the template.</p>
                </div>
            </div>

            <div class="faq-item">
                <div class="faq-header">
                    <div class="expand-icon"></div>
                    <h3>Why am I seeing red error text in my rubric?</h3>
                </div>
                <div class="faq-content">
                    <p>These errors will appear if Kangarubric cannot find CLOs or percentage values in the criterion cell.</p>
                    <p>For best results, format percentages like this: <strong>(50%)</strong><br>And CLOs like this: <strong>(CLO 1, 2, 3)</strong></p>
                </div>
            </div>

            <div class="faq-item">
                <div class="faq-header">
                    <div class="expand-icon"></div>
                    <h3>What happened to my bold/italics/lists?</h3>
                </div>
                <div class="faq-content">
                    <p>Canvas does not support rich text in rubrics. Bold, italics and underlines are discarded, while lists are converted to plain text using a hyphen/dash as the marker.</p>
                </div>
            </div>

            <div class="faq-item">
                <div class="faq-header">
                    <div class="expand-icon"></div>
                    <h3>Why are all the new lines/paragraph breaks being discarded?</h3>
                </div>
                <div class="faq-content">
                    <p>Canvas has exceptionally poor implementation of line breaks in rubrics, and unfortunately Kangarubric has to work around these limitations and bugs. As of 14/2/25, Kangarubric will technically maintain all your line breaks <strong>in rating descriptions only</strong>. An upcoming AU Canvas update will enable you to see them.</p>
                    <p>Line breaks in criteria descriptions are discarded because keeping them results in formatting errors and import failures. Until Instructure fixes this, Kangarubric will discard line breaks in criteria descriptions. You can add them back in manually.</p>
                </div>
            </div>

            <div class="faq-item">
                <div class="faq-header">
                    <div class="expand-icon"></div>
                    <h3>Why are my criteria being renamed to 'Criterion 1', 'Criterion 2', etc.?</h3>
                </div>
                <div class="faq-content">
                    <p>Since criterion names share a cell with the description we cannot reliably tell where the name ends and the description begins. You can edit the names manually either in Kangarubric or in Canvas.</p>
                </div>
            </div>

            <div class="faq-item">
                <div class="faq-header">
                    <div class="expand-icon"></div>
                    <h3>Why is some content missing from my rubric?</h3>
                </div>
                <div class="faq-content">
                    <p>While this shouldn't happen, it is possible.</p>
                    <p>Kangarubric only expects to find paragraph text and lists in any rubric table cell. If your rubric contains any other content (such as images or hyperlinks), it probably won't work. Canvas doesn't support anything other than plain text anyway.</p>
                    <p>If you you don't think there's anything wrong with your course details form and you are still having problems with Kangarubric, please email the word document, CSV file (if possible) and a detailed description of the problem to <a href="mailto:tim.churchward@adelaide.edu.au">Tim Churchward</a>.</p>
                </div>
            </div>

            <div class="faq-item">
                <div class="faq-header">
                    <div class="expand-icon"></div>
                    <h3>I'd like to share some feedback/suggestions</h3>
                </div>
                <div class="faq-content">
                    <p>Please email them to <a href="mailto:tim.churchward@adelaide.edu.au">Tim Churchward</a> :)</p>
                </div>
            </div>

            
        </div>

        <footer>
            <div></div>
            <p>Made with <span class="heart">â™¥</span> for wonderful people like you.</p>
            <span>v0.4</span>
        </footer>
    </div>

    <script>
        // Add click handlers for FAQ accordions
        document.querySelectorAll('.faq-header').forEach(header => {
            header.addEventListener('click', () => {
                header.parentElement.classList.toggle('expanded');
            });
        });

        // Debug mode
        function log(message) {
            console.log(`${new Date().toLocaleTimeString()} - ${message}`);
        }

        // Helper function to get all text content from a cell
        function getAllTextContent(cell) {
            return Array.from(cell.getElementsByTagName('p'))
                .map(p => p.textContent.trim())
                .join(' ');
        }

        // Process HTML content into a single paragraph with preserved formatting
        function processHtmlContent(element) {
            const p = document.createElement('p');
            let isFirstBlock = true;
            
            // Helper function to process lists recursively
            function processListItems(listElement, level = 0) {
                const items = listElement.children;
                const results = [];
                
                Array.from(items).forEach((item, index) => {
                    // Get the item's direct text content (excluding nested lists)
                    let itemText = '';
                    Array.from(item.childNodes).forEach(node => {
                        if (node.nodeType === Node.TEXT_NODE) {
                            itemText += node.textContent;
                        } else if (node.tagName !== 'UL' && node.tagName !== 'OL') {
                            itemText += node.textContent;
                        }
                    });
                    
                    // Create the indentation
                    const indent = ' '.repeat(4 * level);
                    const marker = listElement.tagName === 'UL' ? '- ' : `${index + 1}. `;
                    results.push(indent + marker + itemText);
                    
                    // Process any nested lists
                    const nestedLists = item.querySelectorAll(':scope > ul, :scope > ol');
                    nestedLists.forEach(nestedList => {
                        const nestedItems = processListItems(nestedList, level + 1);
                        results.push(...nestedItems);
                    });
                });
                
                return results;
            }
            
            // Process each block element (p, ul, ol) in order
            const blocks = element.children;
            Array.from(blocks).forEach(block => {
                // If not the first block, add a line break
                if (!isFirstBlock) {
                    p.appendChild(document.createElement('br'));
                }
                isFirstBlock = false;

                if (block.tagName === 'UL' || block.tagName === 'OL') {
                    // Process list items recursively
                    const listLines = processListItems(block);
                    listLines.forEach((line, index) => {
                        if (index > 0) p.appendChild(document.createElement('br'));
                        p.appendChild(document.createTextNode(line));
                    });
                } else {
                    // Process paragraph content
                    const content = block.innerHTML;
                    const temp = document.createElement('div');
                    temp.innerHTML = content;
                    
                    // First, collect all text and br nodes
                    const nodes = [];
                    const walker = document.createTreeWalker(
                        temp,
                        NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
                        {
                            acceptNode: function(node) {
                                if (node.nodeType === Node.TEXT_NODE) return NodeFilter.FILTER_ACCEPT;
                                if (node.tagName === 'BR') return NodeFilter.FILTER_ACCEPT;
                                return NodeFilter.FILTER_SKIP;
                            }
                        }
                    );
                    
                    let node;
                    while (node = walker.nextNode()) {
                        nodes.push(node);
                    }
                    
                    // Then process them as a group
                    if (nodes.length > 0) {
                        let text = '';
                        nodes.forEach(node => {
                            if (node.nodeType === Node.TEXT_NODE) {
                                text += node.textContent;
                            } else if (node.tagName === 'BR') {
                                text += '\n';
                            }
                        });
                        
                        const lines = text.split('\n');
                        lines.forEach((line, index) => {
                            if (index > 0) p.appendChild(document.createElement('br'));
                            p.appendChild(document.createTextNode(line));
                        });
                    }
                }
            });

            // Trim the start and end without losing line breaks
            const firstChild = p.firstChild;
            const lastChild = p.lastChild;
            
            // Trim start
            if (firstChild && firstChild.nodeType === Node.TEXT_NODE) {
                firstChild.textContent = firstChild.textContent.trimStart();
            }
            
            // Trim end
            if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
                lastChild.textContent = lastChild.textContent.trimEnd();
            }
            
            return p;
        }

        // Helper function to process a criterion cell
        function processCriterionCell(cell, criterionIndex) {
            // Create container
            const container = document.createElement('div');
            container.className = 'criterion-cell';

            // Create header (name and score)
            const header = document.createElement('div');
            header.className = 'criterion-header';

            // 1. Set criterion name
            const nameSpan = document.createElement('span');
            nameSpan.className = 'criterion-name';
            nameSpan.contentEditable = 'true';
            nameSpan.textContent = `Criterion ${criterionIndex}`;
            header.appendChild(nameSpan);

            // 2. Find maximum score
            let maxScore = null;
            let scoreText = '';
            const scoreMatches = getAllTextContent(cell).match(/\(?\d{1,3}%\)?/g);
            
            if (!scoreMatches) {
                scoreText = '(NotFound%)';
            } else if (scoreMatches.length > 1) {
                scoreText = '(Error%)';
            } else {
                maxScore = parseInt(scoreMatches[0].match(/\d+/)[0]);
                scoreText = `(${maxScore}%)`;
            }

            const scoreSpan = document.createElement('span');
            scoreSpan.className = maxScore ? 'criterion-score' : 'error-text';
            scoreSpan.contentEditable = 'true';
            scoreSpan.textContent = scoreText;
            header.appendChild(scoreSpan);
            container.appendChild(header);

            // Get all paragraphs for processing
            const paragraphs = Array.from(cell.getElementsByTagName('p'));
            let textContent = '';

            // 3. First check for potentially ambiguous CO references
            const coRegex = /(?:\((?:COs?\W*\s*\d+(?:\s*[,;&]\s*(?:COs?\W*\s*)?\d+)*)\))|(?:COs?\W*\s*\d+(?:\s*[,;&]\s*(?:COs?\W*\s*)?\d+)*)/i;
            const coMatch = getAllTextContent(cell).match(coRegex);
            if (coMatch && !hasShownCOWarning) {
                const confirmed = confirm('Warning: Found "CO" references in your rubric (e.g. "' + coMatch[0] + '"). ' +
                    'These could be Course Outcomes or chemical compounds (like CO2). ' +
                    'To avoid ambiguity, these will not be processed. ' +
                    'Please use "CLO" instead of "CO" if you meant Course Learning Outcomes.\n\n' +
                    'Click OK to continue processing the rest of the rubric.');
                if (!confirmed) {
                    return;
                }
                hasShownCOWarning = true; // Mark that we've shown the warning
            }

            // 4. Find CLOs
            let cloText = '';
            // Match either a full group of CLOs in brackets, or individual CLO references
            // Version that matches both CLO/CO (commented out to avoid accidental matches with CO2 etc)
            // const cloRegex = /(?:\((?:(?:CLOs?|COs?)\W*\s*\d+(?:\s*[,;&]\s*(?:(?:CLOs?|COs?)\W*\s*)?\d+)*)\))|(?:(?:CLOs?|COs?)\W*\s*\d+(?:\s*[,;&]\s*(?:(?:CLOs?|COs?)\W*\s*)?\d+)*)/i;

        // Version that only matches CLO variants (safer as it won't match CO2 etc)
        const cloRegex = /(?:\((?:CLOs?\W*\s*\d+(?:\s*[,;&]\s*(?:CLOs?\W*\s*)?\d+)*)\))|(?:CLOs?\W*\s*\d+(?:\s*[,;&]\s*(?:CLOs?\W*\s*)?\d+)*)/i;
            const cloMatch = getAllTextContent(cell).match(cloRegex);

            if (cloMatch) {
                const cloContent = cloMatch[0];
                // Extract all numbers, handling repeated CLO/CO prefixes
                const numbers = cloContent
                    .replace(/\(|\)/g, '') // remove brackets
                    .split(/[,;&]\s*/) // split on comma, semicolon, or ampersand
                    .map(part => {
                        // Extract just the number from each part, ignoring CLO/CO prefix
                        const numMatch = part.match(/\d+/);
                        return numMatch ? numMatch[0] : null;
                    })
                    .filter(num => num !== null) // remove any failed matches
                    .sort((a, b) => parseInt(a) - parseInt(b)); // sort numerically
                
                cloText = `(CLO ${numbers.join(', ')})`;
            } else {
                cloText = '(CLO NotFound)';
            }

            // 4. Clean up description
            const descriptionDiv = document.createElement('div');
            descriptionDiv.className = 'criterion-description';

            // Clone the cell content for processing
            const contentClone = cell.cloneNode(true);

            // Helper function to clean text after each step
            const cleanText = (str) => {
                return str.replace(/^[^a-zA-Z0-9]+/, '').trim(); // Remove any leading non-alphanumeric chars
            };

            // Function to process text content
            const processText = (text) => {
                // Remove criterion names
                text = text.replace(/(?:Criterion|Criteria)\s+\d+/gi, '');
                text = cleanText(text);
                
                // Remove score if found
                if (maxScore) {
                    text = text.replace(/\(?\d+%\)?/, '');
                    text = cleanText(text);
                }
                
                // Remove CLOs if found
                if (cloMatch) {
                    text = text.replace(cloRegex, '');
                    text = cleanText(text);
                }

                return text;
            };

            // Process all text nodes
            const walker = document.createTreeWalker(
                contentClone,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let node;
            while (node = walker.nextNode()) {
                node.textContent = processText(node.textContent);
            }

            // Clean up empty elements
            const removeEmpty = (element) => {
                Array.from(element.children).forEach(removeEmpty);
                if (element.children.length === 0 && !element.textContent.trim()) {
                    element.remove();
                }
            };
            removeEmpty(contentClone);

            // Process the cleaned content with processHtmlContent
            const processedContent = processHtmlContent(contentClone);
            processedContent.contentEditable = 'true';
            descriptionDiv.appendChild(processedContent);
            container.appendChild(descriptionDiv);

            // Add CLOs
            const cloDiv = document.createElement('div');
            cloDiv.className = cloMatch ? 'criterion-clos' : 'error-text';
            cloDiv.contentEditable = 'true';
            cloDiv.textContent = cloText;
            container.appendChild(cloDiv);

            return container;
        }

        // Initialize the UI
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const processButton = document.getElementById('processButton');
        let currentFile = null;

        // Event listeners for drag and drop
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            handleFileSelection(file);
        });

        dropZone.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            handleFileSelection(file);
        });

        function handleFileSelection(file) {
            // Clear any existing output
            const output = document.getElementById('output');
            output.innerHTML = '';
            
            if (file && file.name.endsWith('.docx')) {
                currentFile = file;
                dropZone.querySelector('p').textContent = `Selected: ${file.name}`;
                processButton.disabled = false;
                log(`File selected: ${file.name}`);
            } else {
                alert('Please select a .docx file');
                log('Invalid file type selected');
            }
        }

        let hasShownCOWarning = false; // Track if we've shown the CO warning for current document
        let avoidCanvasBugs = true; // If true, avoid newlines in criterion descriptions for Canvas compatibility

        processButton.addEventListener('click', async () => {
            if (!currentFile) {
                log('No file selected');
                return;
            }
            
            hasShownCOWarning = false; // Reset the warning flag for each new document

            log('Starting file processing');
            processButton.disabled = true;

            try {
                const arrayBuffer = await currentFile.arrayBuffer();
                log('File loaded into memory');

                const result = await mammoth.convertToHtml({ arrayBuffer });
                log('Document converted to HTML');

                const html = result.value;
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;

                // Helper function to extract content from a table
                const extractTableContent = (table) => {
                    log('Extracting content from nested table with dimensions: ' + 
                        table.getElementsByTagName('tr').length + ' rows x ' + 
                        (table.getElementsByTagName('tr')[0]?.getElementsByTagName('td').length || 0) + ' columns');
                    
                    // Create a single paragraph to hold all content
                    const paragraph = document.createElement('p');
                    paragraph.contentEditable = 'true';
                    
                    // Process each row
                    const rows = table.getElementsByTagName('tr');
                    Array.from(rows).forEach((row, rowIndex) => {
                        const cells = row.getElementsByTagName('td');
                        if (cells.length === 0) return; // Skip header rows
                        
                        Array.from(cells).forEach((cell, i) => {
                            // Get the text content, handling any nested tables recursively
                            const nestedTables = cell.getElementsByTagName('table');
                            if (nestedTables.length > 0) {
                                Array.from(nestedTables).forEach(nestedTable => {
                                    const nestedContent = extractTableContent(nestedTable);
                                    nestedTable.parentNode.replaceChild(nestedContent, nestedTable);
                                });
                            }
                            
                            const cellText = cell.textContent.trim();
                            if (cellText) {
                                if (paragraph.textContent) {
                                    paragraph.textContent += '\n' + cellText;
                                } else {
                                    paragraph.textContent = cellText;
                                }
                            }
                        });
                    });
                    
                    return paragraph;
                };

                // Helper function to flatten nested tables in a cell
                const flattenNestedTables = (element) => {
                    const tables = element.getElementsByTagName('table');
                    // Convert to array since we'll be modifying the DOM
                    Array.from(tables).forEach(table => {
                        const container = extractTableContent(table);
                        table.parentNode.replaceChild(container, table);
                    });
                };

                // Flatten all nested tables in all cells of all tables
                const allTables = tempDiv.getElementsByTagName('table');
                log('Processing ' + allTables.length + ' top-level tables');
                Array.from(allTables).forEach((table, index) => {
                    const cells = table.getElementsByTagName('td');
                    log('Table ' + (index + 1) + ' has ' + cells.length + ' cells');
                    let nestedTableCount = 0;
                    Array.from(cells).forEach((cell, cellIndex) => {
                        const nestedTables = cell.getElementsByTagName('table');
                        if (nestedTables.length > 0) {
                            log('Found ' + nestedTables.length + ' nested table(s) in cell ' + (cellIndex + 1));
                            nestedTableCount += nestedTables.length;
                        }
                        flattenNestedTables(cell);
                    });
                    if (nestedTableCount > 0) {
                        log('Flattened ' + nestedTableCount + ' nested tables in table ' + (index + 1));
                    }
                });
                
                // Find all tables (now without any nested ones)
                const tables = tempDiv.getElementsByTagName('table');
                log(`Found ${tables.length} tables in document`);

                let foundRubricStart = false;
                let foundContentBreakdown = false;
                const rubricTables = [];

                for (let i = 0; i < tables.length; i++) {
                    const table = tables[i];
                    const cells = table.getElementsByTagName('td');
                    
                    if (cells.length === 1) {
                        const cellText = cells[0].textContent.trim();
                        log(`Found single-cell table with text: "${cellText}"`);
                        
                        if (cellText.includes("Assessment Rubric")) {
                            foundRubricStart = true;
                            log('Found Assessment Rubric marker');
                            continue;
                        }
                        
                        if (cellText.includes("Course Content Breakdown")) {
                            foundContentBreakdown = true;
                            log('Found Content Breakdown marker');
                            break;
                        }
                    }

                    if (foundRubricStart && !foundContentBreakdown && cells.length > 1) {
                        rubricTables.push(table);
                        log('Found a rubric table');
                    }
                }

                // Display the rubrics
                const output = document.getElementById('output');
                output.innerHTML = '';

                if (rubricTables.length === 0) {
                    output.innerHTML = '<p>No rubrics found in the document.</p>';
                    log('No rubrics found');
                } else {
                    log(`Found ${rubricTables.length} rubric tables`);
                    
                    // Clear the output before adding new content
                    output.innerHTML = '';
                    
                    rubricTables.forEach((table, index) => {
                        // Create the accordion container
                        const rubricDiv = document.createElement('div');
                        rubricDiv.className = 'rubric-accordion expanded';
                        
                        // Create header container
                        const headerDiv = document.createElement('div');
                        headerDiv.className = 'rubric-header';
                        
                        // Add expand icon
                        const expandIcon = document.createElement('div');
                        expandIcon.className = 'expand-icon';
                        headerDiv.appendChild(expandIcon);
                        
                        // Create content container
                        const contentDiv = document.createElement('div');
                        contentDiv.className = 'rubric-content';
                        
                        // Add click handler for accordion
                        headerDiv.addEventListener('click', () => {
                            rubricDiv.classList.toggle('expanded');
                        });
                        
                        // Extract assignment name from first row of this table
                        let assignmentName = '';
                        const firstRow = table.rows[0];
                        if (firstRow) {
                            const paragraphs = firstRow.getElementsByTagName('p');
                            for (const p of paragraphs) {
                                const text = p.textContent.trim();
                                if (text) {
                                    assignmentName = text;
                                    break;
                                }
                            }
                        }

                        // Add heading
                        const heading = document.createElement('h2');
                        heading.textContent = assignmentName || `Rubric ${index + 1}`;
                        headerDiv.appendChild(heading);
                        rubricDiv.appendChild(headerDiv);

                        // Create clean table
                        const cleanTable = document.createElement('table');
                        cleanTable.className = 'rubric-table';
                        
                        // Create header
                        const thead = document.createElement('thead');
                        const headerRow = document.createElement('tr');
                        const headers = ['Criteria', 'High Distinction', 'Distinction', 'Credit', 'Pass', 'Fail'];
                        
                        headers.forEach(text => {
                            const th = document.createElement('th');
                            th.textContent = text;
                            headerRow.appendChild(th);
                        });
                        
                        thead.appendChild(headerRow);
                        cleanTable.appendChild(thead);
                        
                        const tbody = document.createElement('tbody');
                        cleanTable.appendChild(tbody);

                        // Clean up the table
                        const rows = table.getElementsByTagName('tr');
                        let skipNextRow = false;
                        let criterionNumber = 1; // Initialize criterion counter for this table
                        
                        // Start from index 1 to skip the title row
                        for (let i = 1; i < rows.length; i++) {
                            const row = rows[i];
                            
                            // Skip the Course Learning Outcomes row and the row after it
                            const rowText = row.textContent.trim().toLowerCase();
                            if (rowText.includes('course learning outcomes')) {
                                skipNextRow = true;
                                continue;
                            }
                            if (skipNextRow) {
                                skipNextRow = false;
                                continue;
                            }

                            // Clean up paragraphs in the row
                            const cells = row.getElementsByTagName('td');
                            let hasContent = false;

                            const newRow = document.createElement('tr');
                            for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {
                                const cell = cells[cellIndex];
                                const newCell = document.createElement('td');

                                // Only process the first cell (criteria cell) specially
                                if (cellIndex === 0) {
                                    // Check if the cell has any non-whitespace content
                                    const cellContent = getAllTextContent(cell).trim();
                                    if (cellContent) {
                                        newCell.appendChild(processCriterionCell(cell, criterionNumber));
                                        criterionNumber++; // Increment counter after processing each criterion cell
                                        hasContent = true;
                                    }
                                } else {
                                    // Process non-criterion cells
                                    const p = processHtmlContent(cell);
                                    if (p.hasChildNodes()) {
                                        p.contentEditable = 'true';
                                        newCell.appendChild(p);
                                        hasContent = true;
                                    }
                                }
                                
                                newRow.appendChild(newCell);
                            }

                            // Only add rows that have actual content
                            if (hasContent) {
                                tbody.appendChild(newRow);
                            }
                        }

                        // Add the clean table to the rubric div
                        contentDiv.appendChild(cleanTable);
                        rubricDiv.appendChild(contentDiv);
                        
                        // After processing, check if the table is blank
                        const isBlankTable = Array.from(cleanTable.rows).every(row => {
                            // Check all cells except the first one
                            return Array.from(row.cells).slice(1).every(cell => !getAllTextContent(cell).trim());
                        });

                        if (isBlankTable) {
                            // Remove the table and its preceding heading
                            rubricDiv.removeChild(headerDiv);
                            rubricDiv.removeChild(contentDiv);
                        } else {
                            // Add a download button for CSV export
                            const downloadButton = document.createElement('button');
                            downloadButton.textContent = 'Download CSV';
                            downloadButton.onclick = function() {
                                const csvContent = generateCSVContent(cleanTable, heading.textContent.trim());
                                downloadCSV(csvContent, `${heading.textContent.trim().replace(/\s+/g, '_')}_rubric.csv`);
                            };
                            contentDiv.appendChild(downloadButton);
                            rubricDiv.appendChild(contentDiv);
                        }

                        // Add the complete rubric div to the output
                        output.appendChild(rubricDiv);
                        
                        // If this is the first rubric, scroll to its heading
                        if (index === 0) {
                            // Use requestAnimationFrame to wait for DOM update
                            requestAnimationFrame(() => {
                                const firstH2 = output.querySelector('h2');
                                if (firstH2) {
                                    firstH2.scrollIntoView({ behavior: 'smooth' });
                                }
                            });
                        }
                    });

                    // Function to generate CSV content using Papa Parse
                    function generateCSVContent(table, rubricName) {
                        const rows = Array.from(table.rows);
                        const headerRow = rows[0];
                        const headers = Array.from(headerRow.cells).slice(1).map(cell => cell.textContent.trim());

                        // First row is the header
                        const csvData = [[
                            'Rubric Name', 'Criteria Name', 'Criteria Description', 'Criteria Enable Range',
                            'Rating Name', 'Rating Description', 'Rating Points',
                            'Rating Name', 'Rating Description', 'Rating Points',
                            'Rating Name', 'Rating Description', 'Rating Points',
                            'Rating Name', 'Rating Description', 'Rating Points',
                            'Rating Name', 'Rating Description', 'Rating Points'
                        ]];

                        // Process each criterion row
                        for (let i = 1; i < rows.length; i++) {
                            const row = rows[i];
                            const criterionCell = row.cells[0];
                            const criterionName = criterionCell.querySelector('.criterion-name').textContent;
                            const criterionScore = criterionCell.querySelector('.criterion-score')?.textContent || '';
                            const fullCriterionName = `${criterionName} ${criterionScore}`;
                            // Get description content and handle line breaks based on avoidCanvasBugs setting
                            const descriptionP = criterionCell.querySelector('.criterion-description p');
                            let criterionDescription = '';
                            if (descriptionP) {
                                if (avoidCanvasBugs) {
                                    // For Canvas compatibility, replace <br> with spaces
                                    criterionDescription = descriptionP.innerHTML
                                        .replace(/<br\s*\/?>/gi, ' ')
                                        .replace(/\s+/g, ' '); // Normalize spaces
                                    // Set the modified content back to get proper text extraction
                                    descriptionP.innerHTML = criterionDescription;
                                    criterionDescription = descriptionP.textContent.trim();
                                } else {
                                    // Normal processing with newlines
                                    descriptionP.innerHTML = descriptionP.innerHTML.replace(/<br\s*\/?>/gi, '\n');
                                    criterionDescription = descriptionP.textContent;
                                }
                            }
                            let maxPointsText = 0;
                            if (criterionCell.querySelector('.criterion-score')) {
                                maxPointsText = criterionCell.querySelector('.criterion-score').textContent.match(/\d+/);
                            }
                            const maxPoints = maxPointsText ? parseInt(maxPointsText[0]) : 0;

                            // Helper function to escape CSV field and handle special characters
                            // No need for escapeCSV anymore - Papa Parse handles this

                            // Get CLOs
                            const clos = criterionCell.querySelector('.criterion-clos')?.textContent || '';
                            const fullDescription = criterionDescription + (clos ? ` ${clos}` : '');

                            const rowData = [
                                rubricName,
                                fullCriterionName,
                                fullDescription,
                                'true' // Criteria Enable Range
                            ];

                            headers.forEach((ratingName, index) => {
                                // Get the cell's paragraph content to preserve line breaks
                                const cell = row.cells[index + 1];
                                const p = cell.querySelector('p');
                                // Replace <br> tags with newlines before getting text content
                                if (p) {
                                    // Convert <br> to newlines in the HTML
                                    p.innerHTML = p.innerHTML.replace(/<br\s*\/?>/gi, '\n');
                                }
                                const ratingDescription = p ? p.textContent : cell.textContent.trim();
                                let ratingPoints = 0;
                                switch (ratingName) {
                                    case 'High Distinction':
                                        ratingPoints = maxPoints;
                                        break;
                                    case 'Distinction':
                                        ratingPoints = (maxPoints * 0.85 - 0.1).toFixed(1);
                                        break;
                                    case 'Credit':
                                        ratingPoints = (maxPoints * 0.75 - 0.1).toFixed(1);
                                        break;
                                    case 'Pass':
                                        ratingPoints = (maxPoints * 0.65 - 0.1).toFixed(1);
                                        break;
                                    case 'Fail':
                                        ratingPoints = (maxPoints * 0.5 - 0.1).toFixed(1);
                                        break;
                                }

                                rowData.push(ratingName, ratingDescription, ratingPoints);
                            });

                            csvData.push(rowData);
                        }

                        // Use Papa Parse to generate the CSV
                        return Papa.unparse(csvData, {
                            quotes: true, // Quote fields that need it
                            quoteChar: '"',
                            escapeChar: '"',
                            newline: '\n', // Explicitly set newline character
                        });
                    }

                    // Function to trigger CSV download
                    function downloadCSV(csvContent, filename) {
                        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                        const link = document.createElement('a');
                        const url = URL.createObjectURL(blob);
                        link.setAttribute('href', url);
                        link.setAttribute('download', filename);
                        link.style.visibility = 'hidden';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    }
                }
            } catch (error) {
                log(`Error processing file: ${error.message}`);
                alert('Error processing file. Check the debug log for details.');
            } finally {
                processButton.disabled = false;
            }
        });

        log('Application initialized');
    </script>
   
</body>
</html>
